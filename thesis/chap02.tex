\chapter{Superfícies Baseada em Pontos}
\label{cap:02}
Superfícies baseada em pontos ganharam recentemente a atenção da
comunidade de computação gráfica \cite{PBGBook2007}. Geralmente são provenientes
de \textit{scanners} $3D$ que amostram a superfície do objeto gerando uma nuvem
de pontos $\mathbf{\mathcal P}$. Operações de filtragem \cite{Alexa2004} são
definidas para reduzir o ruído e preencher regiões com buracos. 
Nesta dissertação iremos assumir que o conjunto de pontos $\mathbf{\mathcal P}$
é livre de ruídos com amostras adequadamente distribuídas na superfície.

Neste capítulo, discutiremos as origens e definições de pontos como
primitiva geométrica de renderização. Na seção \ref{cap02:sec:origens} será
apresentado um breve histórico, enquanto que nas seções \ref{cap02:sec:puro} e
\ref{cap02:sec:orientado} a primitiva será descrita em mais detalhes. Por último discutiremos 
os \textit{Splats} na seção \ref{cap02:sec:splat}, que são uma extensão da
representação pura por pontos.
\section{Pontos como Primitiva Universal de Visualização}
\label{cap02:sec:origens}

Visualização de modelos representados como uma coleção de pontos não
é uma ideia recente, na década de $70$ por exemplo, os primeiros vídeo games já
representavam explosões de naves espaciais usando pontos luminosos.
Pontos também foram uma representação popular para trabalhos de simulações
baseadas em
partículas, especialmente por existirem situações onde as representações
clássicas encontram dificuldades em definir a superfície. Uma partícula pode ser
vista como um
ponto em $3D$ acrescido de alguns atributos, como tamanho, densidade,
velocidade, entre outros. Em $1979$ Charles Csuri et al.~\cite{Csuri79} usaram
partículas estáticas para renderizar fumaça; em $1982$ Jim Blinn~\cite{Blinn82}
usou partículas para
representar nuvens e poeira; no mesmo período, Reeves~\cite{Reeves83} apresentou
seu famoso sistemas de partículas, mais genérico que os
anteriores, que permitia simular fogo, explosões, etc..

Em $1985$, Levoy e Whitted~\cite{LevoyW1985} foram os primeiros a considerar o
uso de pontos como primitiva universal de modelagem e renderização. Eles
propuseram representar superfícies genéricas como um conjunto de pontos $3D$
suficientemente denso, de modo a
possibilitar a renderização da superfície contínua. De fato, a proposta era um
pouco ambiciosa ao colocar os pontos como uma meta-primitiva, desta forma
todas representações deveriam ser convertidas para pontos em um certo
momento permitindo a unificação dos algoritmos de visualização. Para reconstruir
uma superfície contínua, os pontos são incrementados com valores 
de normal, cor, um coeficiente de transparência, além de um valor que estima a 
densidade local, permitindo que o ponto projetado possua uma área de cobertura maior
do que a de um pixel (Figura \ref{fig:levoyWhitted}).

%Superfícies baseada em pontos
%recentetimente tem ganhado atenção da comunidade
%de computação gráfica [sites]. Comumente são obtidos de $3D$
%\textit{scanner} [sites], o resultado é uma nuvem de pontos $P$, que recobre a
%superfície do objeto. Operações de processamento e filtragem[Ver Tese tamy
%Capitulo 2] são definidos para reduzir o ruído e preencher regiões com buracos
%[cites]. Nessa dissertação iremos assumir que o conjunto de pontos $P$ é livre
%de ruídos e portanto com amostras adquadamente distribuídas na superfície.
%Neste capítulo, iremos mostrar uma definição de superficie de pontos,
%\textit{splats}. \textit{Splats} são uma extensão das superfícies puramente
%baseadas em pontos assossiando normal e um extensão aos pontos, formando-se
%assim, um disco orientado.


\begin{figure}[ht]
\centering
\includegraphics[width=15.0cm]{img/cap02/gaelwittenAndLevoy} 
\caption{Renderização Baseada em Pontos proposta por Levoy e Whitted (
Retirada de \cite{LevoyW1985}). $(a)$ Ponto como primitiva universal de
renderização. $(b)$ \textit{z-buffer} com tolerância para reconstruir uma
superfície contínua.
\textbf{$(a)$} }
\label{fig:levoyWhitted}
\end{figure}

\section{Pontos Puros}
\label{cap02:sec:puro}
Inicialmente consideramos uma nuvem de pontos onde não haja nenhuma informação
de topologia ou densidade da superfície. Na prática, esta representação
dificilmente é utilizada diretamente, pois não é possível elaborar efeitos de iluminação sem
ao menos a informação dos vetores normais. Xu et al.~\cite{Xu2004} apresentaram uma técnica de renderização sem
informação de normal, porém tratavam apenas das silhuetas e não da superfície completa.

\section{Pontos Orientados}
\label{cap02:sec:orientado}
Com uma nuvem de pontos suficientemente densa, é possível estimar as normais
da superfície em cada ponto analisando sua vizinhança local. Assume-se o
conjunto de pontos como uma coleção de posições $\mathbf{\mathcal P} =
\{\mathbf{c}_i\}$ no $\mathbf R^{3}$, $i \in
\{1,\ldots,N\}$. Como não há informação de conectividade assumimos a utilização
de algum método que nos forneça os $k$-vizinhos mais próximos do ponto,
definidos
como um subconjunto de $k$ pontos com menor distância Euclidiana ao ponto dado.
No capítulo \ref{chapter:3} será apresentada uma estrutura eficiente para obter
os 
$k$-vizinhos de uma nuvem de pontos; no entanto, assumindo-se que são dados os $k$ vizinhos
$\mathbf{\mathcal N}_{\mathbf{\mathcal 
P}}^{k} =
\{\mathbf{c}_1,\ldots,\mathbf{c}_k\}$ de um ponto $\mathbf{c}_i$, a normal no
ponto pode ser obtida pela análise da matriz de covariância, definida como:
\begin{equation}
 \mathbf{C} =  \displaystyle\sum_{j = 1}^k{(\mathbf{c}_j -
 \bar{\mathbf{c}})({\mathbf{c}}_j - \bar{\mathbf{c}})^T},
\label{eq1}
\end{equation}
\noindent onde $\bar{\mathbf{c}} = \frac{1}{k}\sum_{j = 1}^k{\mathbf{c}_j}$ é a
média de todos os vizinhos. Como a matriz $3 \times 3$ é semi-definida positiva e
simétrica, ela possui todos os seus auto-valores reais. Desta forma pode-se
tomar o auto-vetor correspondente ao menor auto-valor como uma estimativa da
direção da normal da superfície no ponto $\mathbf{c}_i$.

Entretanto, a informação de normal geralmente não é suficiente para gerar uma
visualização contínua da superfície, sendo necessário estimar o espaço
entre pontos vizinhos, ou seja, uma valor local de densidade. Esta informação
pode ser gerada implicitamente em superfícies amostradas de forma regular, 
porém muitas algumas regiões podem ficar super-amostradas, já que áreas planares
são consideradas com a mesma resolução do que áreas com grandes variações de curvatura. Desta maneira,
\textit{splats} (seção a seguir) constituem uma maneira simples de representar
adaptativamente nuvens de pontos.

\begin{figure}[ht]
\centering
\includegraphics[width=15.0cm]{img/cap02/bartEllpse} 
\caption{\textbf{Esquerda:} um modelo $3D$ representado por \textit{splats}.
\textbf{Centro:}
visão ampliada da superfície com \textit{splats} renderizados com
metade dos valores dos raios originais. \textbf{Direita:} um \textit{splat}
elíptico é definido por uma posição $\mathbf{c}_i$ e dois eixos tangentes
$\mathbf{t}_i^1$ e $\mathbf{t}_i^2$ (retirada de~\cite{Bart2006}). }
\label{fig:bartellipse}
\end{figure}

\section{\textit{Splat}}
\label{cap02:sec:splat}
Os \textit{splats} foram propostos primeiramente por Pfister et
al.\cite{Pfister2000} que introduziram a ideia de ``\textit{surfel}'' e
interpolação local dos pontos projetados. Este trabalho foi
estendido por Zwicker et al \cite{Zwicker2001} em 2001, introduzindo o conceito
de \textit{Surface Splatting}, uma das técnicas mais populares de renderização de superfícies
baseadas
em pontos. Neste trabalho foi proposto o uso do filtro
EWA
(\textit{Elliptical Weighted Average}\abbrev{EWA}{\textit{Elliptical Weighted
Average}}) para reconstruir a superfície em espaço de imagem utilizando os \textit{splats}
projetados.
Um \textit{splat} pode ser definido como circular ou elíptico como discutido por 
Kobbelt e Botsch \cite{Kobbelt2004}; nesta dissertação usaremos aqueles elípticos.

\subsection{\textit{Splat} Elíptico}
\textit{Splats} são definidos como pequenas elipses com centro definido
pela posição do ponto, e vetor normal pela normal da superfície no ponto. Desta
forma, cada \textit{splat} pode ser definido unicamente por uma posição 
$\mathbf{c}_i$ e dois vetores $\mathbf{t}_i^1$ e $\mathbf{t}_i^2$ ortogonais e
tangentes à superfície (veja Figura \ref{fig:bartellipse}), onde os tamanhos
dos vetores definem a extensão da elipse.

Existem alguns algoritmos para converter superfícies de pontos pura em
representações baseada em \textit{splats} \cite{WuK04,ProgressiveSplat2005}.
A partir dos vetores a normal por ser facilmente computada usando os eixos
principais:
\begin{equation}
\mathbf{n}_i = \frac{\mathbf{t}_i^1 \times \mathbf{t}_i^2}
					{\| \mathbf{t}_i^1\times \mathbf{t}_i^2
\|}.
\label{eq1}
\end{equation}
Um ponto $\mathbf{c}$ sobre o plano definido por
$\mathbf{c}_i$, $\mathbf{t}_i^1$ e $\mathbf{t}_i^2$, também estará no interior
do \textit{splat} se a seguinte condição for satisfeita:

\begin{equation}
 t_1^2 + t_2^2 = \frac{({ \mathbf{t}_i^1}^T (\mathbf{c} - \mathbf{c}_i))^2  }
 					  {({\mathbf{t}_i^1}^T
{\mathbf{t}_i^1})^2 } + 
 					  \frac{({\mathbf{t}_i^2}^T (\mathbf{c}
- \mathbf{c}_i))^2 }
 					  {     ({\mathbf{t}_i^2}^T
{\mathbf{t}_i^2})^2 }
 \leq 1,
\label{eq1}
\end{equation}
onde $\mathbf{t}_1$  e $\mathbf{t}_2$ definem a parametrização dos pontos no espaço do
\textit{splat}. Esta formula pode ser simplificada usando-se
$\mathbf{t}_i^{1^\prime} = \mathbf{t}_i^1 / ({\mathbf{t}_i^1}^T
\mathbf{t}_i^1)$ e ${\mathbf{t}_i^{2^\prime} =
\mathbf{t}_i^1/({\mathbf{t}_i^2}^T
\mathbf{t}_i^2)}$:

\begin{equation}
 t_1^2 + t_2^2 = ( {{\mathbf{t}_i^{1'}}}^T (\mathbf{c} - \mathbf{c}_i))^2  + (
 {\mathbf{t}_i^{2'}}^T (\mathbf{c} - \mathbf{c}_i))^2 \leq 1.
\label{eq1}
\end{equation}

Dada esta propriedade, uma definição formal de \textit{splat} é exposta
abaixo:

\noindent
\textbf{Definição 1.}( \textit{Splat} Elíptico) O \textit{splat} $s_i$ com
centro $\mathbf{c}_i$ e eixos principais $\mathbf{t}_i^1$ e $\mathbf{t}_i^2$ e
normal $\mathbf{n}_i$ é definido como: 

\begin{equation}
 s_i = \{ \mathbf{c} \in \mathbf{R}^3  \lvert  \mathbf{n}_i^T(\mathbf{c} -
 \mathbf{c}_i) = 0 \wedge ( {\mathbf{t}_i^{1'}}^T (\mathbf{c} -
 \mathbf{c}_i))^2 + ( {\mathbf{t}_i^{2'}}^T (\mathbf{c} - \mathbf{c}_i))^2 \leq
 1\}.
\label{eq1}
\end{equation}

Como exposto por Kobbelt e Botsch~\cite{Kobbelt2004}, representar
uma superfície como um conjunto de \textit{splats} provê uma aproximação da
mesma ordem das malhas poligonais. Ainda mais, como \textit{splats} não
possuem informação de conectividade, herdam a flexibilidade das primitivas
de pontos.

\label{splat:elliptico}
\subsection{\textit{Surface Splatting}}

\begin{figure}[ht]
\centering
\includegraphics[width=15.0cm]{img/cap02/phongsplat} 
\caption{\textbf{Esquerda:} splats renderizados com metade dos valores dos raios
para efeitos de ilustração. \textbf{Centro-esquerda:} splats renderizados sem
interpolação. \textbf{Centro-direita:} interpolação das cores; \textbf{direita:}
interpolação das normais. Retirada de~\cite{PhongSplat2004}}
\label{fig:manequim}
\end{figure}

A ideia de associar \textit{splats} a pontos foi originada nos primeiros
algoritmos de renderização baseada em pontos~\cite{Pfister2000,Zwicker2001}. O
objetivo era criar um algoritmo de renderização de superfícies 
similar à rasterização de malhas poligonais. Entretanto, ao menos que a
amostragem seja extremamente densa, a projeção simples de pontos no
espaço de imagem resultará em buracos na imagem final (Figura
\ref{fig:ssplat} esquerda). Para evitar este problema, os \textit{splats} são
projetados e a renderização é realizada através da rasterização das elipses
(Figura \ref{fig:ssplat} direita).
Ainda assim, esse procedimento resulta em imagens de baixa qualidade pois gera
descontinuidades entre as elipses (ver figura \ref{fig:manequim}
centro-esquerda). A fim de obter uma imagem de alta qualidade usando este
algoritmo ingênuo, seria necessário uma quantidade muito
grande de amostras, de modo a tornar as descontinuidades imperceptíveis.
 
\begin{figure}[ht]
\centering
\includegraphics[width=15.0cm]{img/cap02/splatting} 
\caption{\textbf{Esquerda:} projeção de pontos com cobertura de um pixel.
\textbf{Direita:} splats com área de cobertura são interpolados para gerar uma
superfície contínua em espaço de imagem. Adaptada de~\cite{Bart2006}}
\label{fig:ssplat}
\end{figure}

Uma maneira de melhorar este algoritmo é tratar as regiões de
interseção entre as elipses (Figura
\ref{fig:manequim} centro-direita e direita). Porém, implementar este
procedimento diretamente no \textit{pipeline} gráfico requer acesso aos valores
de profundidade armazenados (\textit{z-buffer}) para testar se duas elipses que
se intersetam em espaço de imagem pertencem de fato à mesma superfície do
objeto. Infelizmente, na GPU, estes valores de profundidade não são acessíveis
em tempo de renderização, requerendo estratégias mais elaboradas que tratem o
problema em duas passadas: na primeira as elipses são projetadas e rasterizadas
normalmente preenchendo o buffer de profundidade; na segunda as elipses são
interpoladas utilizando o z-buffer da primeria passada como referência.

Para realizar a interpolação é feita uma média ponderada de todas as elipses que
cobrem um dado pixel. Geralmente são utilizados filtros Gaussianos para atribuir
um peso a cada elipse dependendo da distância ao seu centro de projeção.

Ainda mais, a interpolação pode ser realizada de duas
formas distintas: interpolando as cores dos splats (Figura \ref{fig:manequim}
centro-direita) ou as normais (Figura \ref{fig:manequim} direita). 
Na primeira o computo de iluminação é realizado uma vez por elipse e as cores
são interpoladas por pixel (análogo a tonalização \textit{Gouraud}), enquanto que na
segunda estratégia as normais são interpoladas e o cálculo de
iluminação realizado por pixel da imagem, uma técnica conhecida como
\textit{deffered shading}, ou \textit{per-pixel shading}.
